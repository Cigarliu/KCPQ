# KCPQ 项目状态总结

本文档描述当前仓库的真实状态（以代码为准），用于对齐“能做什么 / 不能做什么 / 推荐怎么用”。

## 1. 项目定位

KCPQ 是一个基于 KCP（可靠 UDP）的轻量级 Pub/Sub 消息分发组件，提供类似 NATS 的主题订阅模型（支持 `*` / `>` 通配符），面向低延迟、实时场景。

## 2. 当前关键能力

- Pub/Sub：按 subject 发布与订阅，支持 `*` 单段、`>` 多段通配符
- Context：关键 API 支持超时与取消
- Channel 订阅：提供 `SubscribeChan*` 形式，符合 Go 习惯
- 自动重连：支持断线重连，并恢复订阅（依赖订阅确认/恢复机制）
- 基本统计：Client/Server 提供运行统计，用于观察连接、订阅与消息处理情况
- 强制加密：KCP 层 AES-256 PSK 已强制启用（见下文）

## 3. 强制加密（AES-256 PSK）

当前代码库已强制启用 KCP 层 AES-256 加密：

- 服务端创建：`server.NewServer(addr, aes256Key)`，`aes256Key` 必须为 32 字节
- 客户端连接：`client.ConnectWithContext(ctx, addr, aes256Key)` / `client.Connect(addr, aes256Key)`
- 示例程序通过 `KCPQ_AES256_KEY_HEX`（64 hex）读取 key

这意味着：

- key 不一致会导致双方无法正确通信（表现为订阅/收消息超时或失败）
- 生产环境必须把 key 当作敏感配置管理（环境变量、密钥管理系统、最小权限）

## 4. 推荐用法（最小闭环）

1) 启动示例 server（配置 key）  
2) 启动 subscriber（同一 key）  
3) 启动 publisher（同一 key）  

示例入口位于 `examples/`，建议优先从 `examples/README.md` 开始。

## 5. 已知边界（当前不提供）

- 消息持久化 / 重放 / 消费确认语义（类似 JetStream / Kafka）
- 集群与高可用（多节点路由、复制、一致性）
- 多租户鉴权、ACL、细粒度权限模型

如果你的需求落在上述范围，建议把 KCPQ 作为“低延迟边缘分发层”，后端使用 NATS/Kafka 等持久化系统承接。

## 6. 运维建议（简要）

- 网络：优先保障 `udp/4000` 端到端可达与丢包可控；避免 NAT/防火墙中途重写导致的异常
- 监控：关注连接数、订阅数、重连次数、处理耗时与丢弃计数
- 升级：先灰度客户端再升级服务端；涉及 key 轮换需制定切流策略

